import Foundation

struct CatalogueData: Decodable {
  let brands: [CatalogueBrand]
}

struct CatalogueBrand: Decodable {
  let id: String
  let logo: String
  let name: String?
  let aliases: [String]?
}

enum GeneratorError: Error, LocalizedError {
  case missingScriptPath
  case invalidRepositoryStructure

  var errorDescription: String? {
    switch self {
    case .missingScriptPath:
      return "Unable to resolve script path from command line arguments."
    case .invalidRepositoryStructure:
      return "Unable to infer repository root from script location."
    }
  }
}

func swiftStringLiteral(_ value: String) -> String {
  value
    .replacingOccurrences(of: "\\", with: "\\\\")
    .replacingOccurrences(of: "\n", with: "\\n")
    .replacingOccurrences(of: "\r", with: "\\r")
    .replacingOccurrences(of: "\t", with: "\\t")
    .replacingOccurrences(of: "\"", with: "\\\"")
}

func aliasesLiteral(_ aliases: [String]?) -> String {
  guard let aliases, aliases.isEmpty == false else {
    return "[]"
  }

  let values = aliases
    .map { "\"\(swiftStringLiteral($0))\"" }
    .joined(separator: ", ")

  return "[\(values)]"
}

func optionalLiteral(_ value: String?) -> String {
  guard let value else {
    return "nil"
  }

  return "\"\(swiftStringLiteral(value))\""
}

func resolvePaths() throws -> (catalogueURL: URL, outputURL: URL) {
  guard let scriptPath = CommandLine.arguments.first else {
    throw GeneratorError.missingScriptPath
  }

  let scriptURL = URL(fileURLWithPath: scriptPath).standardizedFileURL
  let scriptsDirectory = scriptURL.deletingLastPathComponent()
  let watchDirectory = scriptsDirectory.deletingLastPathComponent()
  let repoRoot = watchDirectory.deletingLastPathComponent()

  guard watchDirectory.lastPathComponent == "watch-ios" else {
    throw GeneratorError.invalidRepositoryStructure
  }

  let environment = ProcessInfo.processInfo.environment
  let catalogueURL: URL

  if let overridePath = environment["CATALOGUE_JSON_PATH"], overridePath.isEmpty == false {
    if overridePath.hasPrefix("/") {
      catalogueURL = URL(fileURLWithPath: overridePath)
    } else {
      catalogueURL = repoRoot.appendingPathComponent(overridePath)
    }
  } else {
    catalogueURL = repoRoot.appendingPathComponent("catalogue/italy.json")
  }

  let outputURL = watchDirectory.appendingPathComponent("Generated/Brands.swift")
  return (catalogueURL, outputURL)
}

func generateSource(from catalogue: CatalogueData) -> String {
  let generatedAt = ISO8601DateFormatter().string(from: Date())

  let brands = catalogue.brands
    .map { brand in
      let logoUrl = "assets/images/brands/\(brand.logo).svg"
      return "    .init(id: \"\(swiftStringLiteral(brand.id))\", logoUrl: \"\(swiftStringLiteral(logoUrl))\", name: \(optionalLiteral(brand.name)), aliases: \(aliasesLiteral(brand.aliases)))"
    }
    .joined(separator: ",\n")

  return """
// Generated by watch-ios/Scripts/generate-catalogue.swift
// Source: catalogue/italy.json
// Generated at: \(generatedAt)

import Foundation

struct WatchBrand: Sendable {
  let id: String
  let logoUrl: String
  let name: String?
  let aliases: [String]
}

enum WatchBrands {
  static let all: [WatchBrand] = [
\(brands)
  ]
}
"""
}

do {
  let (catalogueURL, outputURL) = try resolvePaths()

  let catalogueData = try Data(contentsOf: catalogueURL)
  let decoder = JSONDecoder()
  let catalogue = try decoder.decode(CatalogueData.self, from: catalogueData)

  let source = generateSource(from: catalogue)

  let outputDirectory = outputURL.deletingLastPathComponent()
  try FileManager.default.createDirectory(at: outputDirectory, withIntermediateDirectories: true)
  try source.write(to: outputURL, atomically: true, encoding: .utf8)

  print("Generated \(outputURL.path)")
} catch {
  fputs("error: \(error.localizedDescription)\n", stderr)
  exit(1)
}
